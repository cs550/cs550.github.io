<H1> Assignment: Tracking Page Faults for a Process</H1>

<H2>
Objective 
</H2>

<p> You will learn how to use kernel-level probing mechanisms to intercept and track kernel events, here specifically page-faults for a specific process.

<H2> 
Description
</H2>

<p> Kprobes enables you to dynamically break into any kernel routine and
collect debugging and performance information non-disruptively. You
can trap at almost any kernel code address(*), specifying a handler
routine to be invoked when the breakpoint is hit.

<ol>

<li> 
Learn how to use kprobes and jprobes in the Linux kernel.
<a href=https://www.kernel.org/doc/Documentation/kprobes.txt> 
https://www.kernel.org/doc/Documentation/kprobes.txt
</a>

<li>
Try these example kernel modules for practice:
<a href=http://lxr.free-electrons.com/source/samples/kprobes/>
http://lxr.free-electrons.com/source/samples/kprobes/
</a>

<li>
Study the 
<a href=http://lxr.free-electrons.com/source/mm/memory.c#L3437>
handle_mm_fault()
</a>
function in the Linux kernel to 
understand when it is invoked and what it does.

<li>
Now create a kernel module that takes the process-ID of an active process as 
an argument (either module parameter or via an ioctl interface), and tracks 
all the virtual addresses on which the target process faults.
Print the virtual addresses on the console using printk.
Show that your code works for any arbitrary target process.

<li> Bonus Section: (optional)
Store the tracked virtual addresses and the time at
which each address was trapped in a kernel buffer, possibly a circular array.
Retrieve the buffer from user space using either an ioctl call
or the /proc interface.
Plot the virtual addresses you tracked as a scatter-plot graph with X-axis 
representing the time and Y-axis representing the virtual address.
Try different types of target processes, such as kernel compilation,
quicksort, sysbench, etc. 
See if you can find any interesting trends in memory access patterns
of a process.
Describe your results in a concise report.


</ol>

<H2>
Grading guidelines
</H2>

<p>  50 - Demonstrating that your code works for a specific process
<br> 40 - Explaining the code, including how kprobes and jprobes work.
<br> 10 - Handle all major error conditions. Clean, modular, and commented code. Clean readable output. No "giant" functions. 
<br> Total = 100
<br>
<br> 40 - Bonus section: (optional) Demonstrate that your code can retrieve tracked virtual addresses from a user space program for any arbitrary process. Submit (with explanation) scatter-plots for different types of processes.

